using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;
using System.Buffers;
using System.Collections.Immutable;
using static Kassa.Shared.ServiceLocator.Analyzer.RcsLocatorBuilderGeneratorStrings;
using Kassa.Shared.Collections;
using System.Collections.Frozen;

namespace Kassa.Shared.ServiceLocator.Analyzer;

[Generator]
public sealed class RcsLocatorBuilderGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var pipeline =
            context.SyntaxProvider.CreateSyntaxProvider(
                static (node, ctx) => CatchServiceRegistration(node),
                static (syntax, ctrx) => GenerateServiceDescriptor(syntax, ctrx))
            .Collect();

        context.RegisterSourceOutput(pipeline, static (context, serviceDescriptors) =>
        {
            context.AddSource("RcsLocatorBuilder.g.cs", RcsLocatorBuilderClassDecloration);
            context.AddSource("RcsLocatorBuilder.scopedInjectAttr.g.cs", ScopeInjectAttributeDecloration);
            context.AddSource("RcsLocatorBuilder.injectConstructorAttr.g.cs", InjectConstructorAttributeDecloration);

            var sortedDescriptors = ReportDiagnosticsAndSort(context, serviceDescriptors);

            var frozenDescriptors = sortedDescriptors.ToFrozenDictionary(x => x.ServiceType, x => x, SymbolEqualityComparer.Default);

            using var registrationBuilder = ImmutableArrayBuilder<MethodDeclarationSyntax>.Rent();

            foreach (var serviceDescriptor in sortedDescriptors)
            {
                var serviceRegister = AddServiceRegisterAndSetSuffix(frozenDescriptors!, serviceDescriptor);

                registrationBuilder.Add(serviceRegister);
            }

            using var fieldsBuilder = ImmutableArrayBuilder<FieldDeclarationSyntax>.Rent();

            foreach (var serviceDescriptor in sortedDescriptors)
            {
                var field = AddFieldsForSingletone(serviceDescriptor);

                if (field is not null)
                {
                    fieldsBuilder.Add(field);
                }
            }

            var registrations = registrationBuilder.ToImmutable();
            registrationBuilder.Dispose();

            var fields = fieldsBuilder.ToImmutable();
            fieldsBuilder.Dispose();

            var addToBuilderMethod = AddToBuilder(sortedDescriptors);

            var rcsLocatorBuilderClass = SyntaxFactory.ClassDeclaration(RcsLocatorBuilderClassName)
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.InternalKeyword), SyntaxFactory.Token(SyntaxKind.StaticKeyword), SyntaxFactory.Token(SyntaxKind.PartialKeyword))
                .AddMembers([.. fields])
                .AddMembers([.. registrations])
                .AddMembers(addToBuilderMethod);

            var namespaceDeclaration = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(RcsLocatorBuilderNamespace))
                .AddMembers(rcsLocatorBuilderClass);

            var compilationUnit = SyntaxFactory.CompilationUnit()
                .AddUsings(
                    SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System")),
                    SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("Kassa.Shared"))
                )
                .AddMembers(namespaceDeclaration)
                .NormalizeWhitespace();

            var source = $@"
// <auto-generated />

{compilationUnit.ToFullString()}";

            context.AddSource("RcsLocatorBuilder.reg.g.cs", source);

        });
    }

    /// <summary>
    /// It's method catches the service registration in the source code.
    /// </summary>
    /// <remarks>
    /// Example of the service registration whic code will catch:
    /// <code>
    /// <![CDATA[
    /// RcsLocatorBuilder.AddTransient<IServiceA, ServiceA>();
    /// RcsLocatorBuilder.AddTransient<ServiceB>();
    /// RcsLocatorBuilder.AddScoped<IServiceC, ServiceC>();
    /// RcsLocatorBuilder.AddScoped<ServiceD>();
    /// RcsLocatorBuilder.AddSignletone<ServiceE>();
    /// RcsLocatorBuilder.AddSignletone<IServiceF,ServiceF>();
    /// ]]>
    /// </code>
    /// </remarks>
    private static bool CatchServiceRegistration(SyntaxNode node)
    {
        if (ContainsErrors(node))
        {
            return false;
        }

        if (node is not InvocationExpressionSyntax invocation)
        {
            return false;
        }

        if (invocation.Expression is not MemberAccessExpressionSyntax memberAccess)
        {
            return false;
        }

        if (memberAccess.Expression is not IdentifierNameSyntax identifierName)
        {
            return false;
        }

        if (identifierName.Identifier.Text is not RcsLocatorBuilderClassName or RcsLocatorBuilderFullName)
        {
            return false;
        }

        if (memberAccess.Name is not GenericNameSyntax genericName)
        {
            return false;
        }

        if (genericName.TypeArgumentList.Arguments.Count is 0 or > 2)
        {
            return false;
        }

        if (genericName.Identifier.Text is not AddTransientMethodName and not AddScopedMethodName and not AddSingletonMethodName)
        {
            return false;
        }

        return true;
    }

    private static ServiceDescriptor? GenerateServiceDescriptor(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        Diagnostic[] diagnostics = [];

        var invocation = (InvocationExpressionSyntax)context.Node;

        var memberAccess = (MemberAccessExpressionSyntax)invocation.Expression;
        var genericName = (GenericNameSyntax)memberAccess.Name;

        var serviceTypeSyntax = genericName.TypeArgumentList.Arguments[0];
        var implementationTypeSyntax = genericName.TypeArgumentList.Arguments.Count == 2
            ? genericName.TypeArgumentList.Arguments[1]
            : serviceTypeSyntax;

        var serviceType = (INamedTypeSymbol)context.SemanticModel.GetTypeInfo(serviceTypeSyntax, cancellationToken).Type!;
        var implementationType = (INamedTypeSymbol)(context.SemanticModel.GetTypeInfo(implementationTypeSyntax, cancellationToken).Type!);

        var constructor = implementationType.InstanceConstructors.Length == 1
            ? implementationType.InstanceConstructors[0]
            : implementationType.InstanceConstructors.FirstOrDefault(x => x.GetAttributes().Any(a => a.AttributeClass?.Name is InjectConstructorAttributeShortName or InjectConstructorAttributeFullName));

        if (constructor is null)
        {
            diagnostics = [Diagnostic.Create(Diagnostics.NotFoundConstructor, implementationType.Locations[0])];
        }

        return new ServiceDescriptor(
            serviceType,
            implementationType,
            constructor!,
            diagnostics,
            (IdentifierNameSyntax)genericName.TypeArgumentList.Arguments[0],
            (IdentifierNameSyntax)genericName.TypeArgumentList.Arguments.ElementAtOrDefault(1),
            genericName);
    }

    private static bool ContainsErrors(SyntaxNode node)
        => node
            .GetDiagnostics()
            .Any(d => d.Severity == DiagnosticSeverity.Error);


    private static ImmutableArray<ServiceDescriptor> ReportDiagnosticsAndSort(SourceProductionContext context, ImmutableArray<ServiceDescriptor?> serviceDescriptors)
    {
        ImmutableArray<ServiceDescriptor> filterDescriptors;

        using (var filterDescriptorsBuilder = ImmutableArrayBuilder<ServiceDescriptor>.Rent())
        {
            foreach (var serviceDescriptor in serviceDescriptors)
            {
                if (serviceDescriptor is not null)
                {
                    if (serviceDescriptor.Diagnostics.Length == 0)
                    {
                        filterDescriptorsBuilder.Add(serviceDescriptor);
                    }
                    else
                    {
                        foreach (var diagnostic in serviceDescriptor.Diagnostics)
                        {
                            context.ReportDiagnostic(diagnostic);
                        }
                    }
                }
            }

            filterDescriptors = filterDescriptorsBuilder.ToImmutable();
        }

        using var sortedDescriptorsBuilder = ImmutableArrayBuilder<ServiceDescriptor>.Rent();

        static bool FilterTransient(ServiceDescriptor descriptor) => descriptor.IsTransient;
        static bool FilterScoped(ServiceDescriptor descriptor) => descriptor.IsScoped;
        static bool FilterSingleton(ServiceDescriptor descriptor) => descriptor.IsSingleton;

        SortByDependencyCount(filterDescriptors, sortedDescriptorsBuilder, FilterTransient);
        SortByDependencyCount(filterDescriptors, sortedDescriptorsBuilder, FilterScoped);
        SortByDependencyCount(filterDescriptors, sortedDescriptorsBuilder, FilterSingleton);

        return sortedDescriptorsBuilder.ToImmutable();

    }

    private static void SortByDependencyCount(
        ImmutableArray<ServiceDescriptor> serviceDescriptors,
        ImmutableArrayBuilder<ServiceDescriptor> sortedDescriptors,
        Func<ServiceDescriptor, bool> filter)
    {
        var count = serviceDescriptors.Length;
        var pool = ArrayPool<ServiceDescriptor>.Shared;
        var tempArray = pool.Rent(count);

        try
        {
            var filteredCount = 0;
            for (var i = 0; i < count; i++)
            {
                var descriptor = serviceDescriptors[i];
                if (filter(descriptor))
                {
                    tempArray[filteredCount++] = descriptor;
                }
            }

            // Sort by the number of dependencies (constructor parameters)
            for (var i = 0; i < filteredCount - 1; i++)
            {
                for (var j = i + 1; j < filteredCount; j++)
                {
                    if (tempArray[i]!.Constructor.Parameters.Length > tempArray[j]!.Constructor.Parameters.Length)
                    {
                        (tempArray[j], tempArray[i]) = (tempArray[i], tempArray[j]);
                    }
                }
            }

            // Add to the final list
            for (var i = 0; i < filteredCount; i++)
            {
                sortedDescriptors.Add(tempArray[i]);
            }
        }
        finally
        {
            // Return the array to the pool
            pool.Return(tempArray, clearArray: true);
        }
    }

    /// <summary>
    /// Added fields for the singleton services. 
    /// </summary>
    /// <remarks>
    /// WARNING: Be sure you have suffix for the method name.
    /// For example:
    /// <code>
    /// private static global::IServiceA? __service_{serviceDescriptor.MethodSuffix} = null!;
    /// </code>
    /// </remarks>
    private static FieldDeclarationSyntax? AddFieldsForSingletone(ServiceDescriptor serviceDescriptor)
    {
        if (!serviceDescriptor.IsSingleton)
        {
            return null;
        }

        var fieldName = $"__service_{serviceDescriptor.MethodSuffix}";

        var typeName = serviceDescriptor.ServiceType.ToDisplayString(
                NullableFlowState.MaybeNull, SymbolDisplayFormat.FullyQualifiedFormat
            );

        // i don't know how create PostfixUnaryExpressionSyntax more correctly
        var nullSupress = SyntaxFactory.ParseExpression("null!");

        var fieldDeclaration = SyntaxFactory.FieldDeclaration(
            SyntaxFactory.VariableDeclaration(
                SyntaxFactory.ParseTypeName(typeName)
            )
            .AddVariables(
                SyntaxFactory.VariableDeclarator(fieldName)
                    .WithInitializer(
                        SyntaxFactory.EqualsValueClause(
                           nullSupress
                        )
                    )
            )
        )
        .AddModifiers(SyntaxFactory.Token(SyntaxKind.PrivateKeyword), SyntaxFactory.Token(SyntaxKind.StaticKeyword));


        return fieldDeclaration;
    }

    private static MethodDeclarationSyntax AddServiceRegisterAndSetSuffix(FrozenDictionary<ISymbol,ServiceDescriptor> allServiceDescriptors,ServiceDescriptor serviceDescriptor)
    {
        serviceDescriptor.MethodSuffix = Guid.NewGuid().ToString("N");
        // Generate method name with suffix
        var methodName = $"GetService_{serviceDescriptor.MethodSuffix}";

        // Generate parameters for the method (constructor parameters)
        var parameters = serviceDescriptor.Constructor.Parameters.Select(param =>
            SyntaxFactory.Argument(
                GetServiceFromLocator(param, serviceDescriptor.IsScoped)
            )
        ).ToArray();

        // Create the method body
        var methodBody = SyntaxFactory.Block(
            SyntaxFactory.SingletonList<StatementSyntax>(
                SyntaxFactory.ReturnStatement(
                    SyntaxFactory.ObjectCreationExpression(
                        SyntaxFactory.ParseTypeName(serviceDescriptor.ImplementationType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)))
                    .AddArgumentListArguments(parameters)
                )
            )
        );

        // Generate method declaration
        var methodDeclaration = SyntaxFactory.MethodDeclaration(
                SyntaxFactory.ParseTypeName(serviceDescriptor.ServiceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)),
                methodName)
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PrivateKeyword),
                          SyntaxFactory.Token(SyntaxKind.StaticKeyword))
            // If service is scoped, add the IServiceProvider serviceProvider parameter
            .AddParameterListParameters(
                serviceDescriptor.IsScoped
                    ? [
                        SyntaxFactory
                            .Parameter(SyntaxFactory.Identifier("serviceProvider"))
                            .WithType(SyntaxFactory.ParseTypeName("global::System.IServiceProvider"))
                      ]
                    : []
            )
            .WithBody(methodBody);

        return methodDeclaration;
    }


    private static InvocationExpressionSyntax GetServiceFromLocator(IParameterSymbol parameterSymbol, bool isHasServiceProvider)
    {
        if (isHasServiceProvider)
        {
            // if has serviceProvider
            // just call serviceProvider.GetRequiredService<TService>()

            return SyntaxFactory.InvocationExpression(
                SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    SyntaxFactory.IdentifierName("serviceProvider"),
                    SyntaxFactory.GenericName("GetRequiredService").AddTypeArgumentListArguments(
                        SyntaxFactory.ParseTypeName(parameterSymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
                    )
                )
            );
        }

        var isScoped = parameterSymbol.GetAttributes().Any(a => a.AttributeClass?.Name is ScopeInjectAttributeShortName or ScopeInjectAttributeName or ScopeInjectAttributeFullName);

        // is service is scoped 
        // RcsLocator.Scoped.GetRequiredService<TService>()
        if (isScoped)
        {
            return SyntaxFactory.InvocationExpression(
                SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        SyntaxFactory.IdentifierName(RcsLocatorCurrentLocator),
                        SyntaxFactory.IdentifierName("Scoped")),
                    SyntaxFactory.GenericName(RcsLocatorGetRequiredService).AddTypeArgumentListArguments(
                        SyntaxFactory.ParseTypeName(parameterSymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
                    )
                )
            );
        }

        // else default RcsLocator.GetRequiredService<TService>()

        return SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        SyntaxFactory.IdentifierName(RcsLocatorCurrentLocator),
                        SyntaxFactory.GenericName(RcsLocatorGetRequiredService).AddTypeArgumentListArguments(
                            SyntaxFactory.ParseTypeName(parameterSymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
                        )
                    )
                );
    }

    private static MethodDeclarationSyntax AddToBuilder(ImmutableArray<ServiceDescriptor> serviceDescriptors)
    {
        // Gemerate method invocation for each service

        // for scoped service:
        // ServiceLocatorBuilder.AddScoped<global::IServiceA>((sp) => GetService_{serviceDescriptor.MethodSuffix}(sp));

        // for transient and singleton service:
        // ServiceLocatorBuilder.AddService<global::IServiceA>(() => GetService_{serviceDescriptor.MethodSuffix}());

        using var methodBuilder = ImmutableArrayBuilder<StatementSyntax>.Rent();

        foreach (var serviceDescriptor in serviceDescriptors)
        {
            var methodName = $"GetService_{serviceDescriptor.MethodSuffix}";

            var methodInvocation = SyntaxFactory.ExpressionStatement(
                SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        SyntaxFactory.IdentifierName(ServiceLocatorBuilderName),
                        serviceDescriptor.IsScoped
                            ? SyntaxFactory.GenericName(ServiceLocatorBuilderAddScopedServiceMethodName).AddTypeArgumentListArguments(
                                SyntaxFactory.ParseTypeName(serviceDescriptor.ServiceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
                            )
                            : SyntaxFactory.GenericName(rviceLocatorBuilderAddServiceMethodName).AddTypeArgumentListArguments(
                                SyntaxFactory.ParseTypeName(serviceDescriptor.ServiceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
                            )
                    )
                ).AddArgumentListArguments(
                    SyntaxFactory.Argument(

                        serviceDescriptor.IsScoped 
                        ? SyntaxFactory.ParenthesizedLambdaExpression(
                            SyntaxFactory.ParameterList(
                                SyntaxFactory.SingletonSeparatedList(
                                    SyntaxFactory.Parameter(
                                        SyntaxFactory.Identifier("sp")
                                    )
                                    .WithType(SyntaxFactory.ParseTypeName("global::System.IServiceProvider"))
                                )
                            ),
                            SyntaxFactory.InvocationExpression(
                                SyntaxFactory.IdentifierName(methodName),
                                SyntaxFactory.ArgumentList(
                                    SyntaxFactory.SingletonSeparatedList(
                                        SyntaxFactory.Argument(SyntaxFactory.IdentifierName("sp"))   
                                    )
                                )
                            )
                        )
                        : SyntaxFactory.ParenthesizedLambdaExpression(
                            SyntaxFactory.InvocationExpression(
                                SyntaxFactory.IdentifierName(methodName)
                            )
                        )
                    )
                )
            );

            methodBuilder.Add(methodInvocation);
        }

        var methodBody = SyntaxFactory.Block(methodBuilder.ToImmutable());

        var methodDeclaration = SyntaxFactory.MethodDeclaration(
            SyntaxFactory.PredefinedType(
                SyntaxFactory.Token(SyntaxKind.VoidKeyword)
            ),
            "AddToBuilder")
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.StaticKeyword))
            .WithBody(methodBody);

        return methodDeclaration;
    }
}