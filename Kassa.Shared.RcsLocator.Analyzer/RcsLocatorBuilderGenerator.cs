using System;
using System.Buffers;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Kassa.Shared.Collections;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using static Kassa.Shared.RcsLocator.Analyzer.RcsLocatorBuilderGeneratorStrings;

namespace Kassa.Shared.RcsLocator.Analyzer;

[Generator]
public sealed class RcsLocatorBuilderGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var pipeline =
            context.SyntaxProvider.CreateSyntaxProvider(
                static (node, ctx) => CatchServiceRegistration(node),
                static (syntax, ctrx) => GenerateServiceDescriptor(syntax, ctrx))
            .Collect();

        context.RegisterSourceOutput(pipeline, static (context, serviceDescriptors) =>
        {
            context.AddSource("RcsLocatorBuilder.g.cs", RcsLocatorBuilderClassDecloration);

            var sortedDescriptors = ReportDiagnosticsAndSort(context, serviceDescriptors);

            using var registrationBuilder = ImmutableArrayBuilder<MethodDeclarationSyntax>.Rent();

            foreach (var serviceDescriptor in sortedDescriptors)
            {
                var serviceRegister = AddServiceRegister(serviceDescriptor);

                registrationBuilder.Add(serviceRegister);
            }

            var registrations = registrationBuilder.ToImmutable();
            registrationBuilder.Dispose();

            var rcsLocatorBuilderClass = SyntaxFactory.ClassDeclaration(RcsLocatorBuilderClassName)
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.InternalKeyword), SyntaxFactory.Token(SyntaxKind.StaticKeyword), SyntaxFactory.Token(SyntaxKind.PartialKeyword))
                .AddMembers(registrations.ToArray());

            var namespaceDeclaration = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(RcsLocatorBuilderNamespace))
                .AddMembers(rcsLocatorBuilderClass);

            var compilationUnit = SyntaxFactory.CompilationUnit()
                .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System")))
                .AddMembers(namespaceDeclaration);

            context.AddSource("RcsLocatorBuilder.g.cs", $@"
// <auto-generated />

{compilationUnit.ToFullString()}");
        });
    }

    /// <summary>
    /// It's method catches the service registration in the source code.
    /// </summary>
    /// <remarks>
    /// Example of the service registration whic code will catch:
    /// <code>
    /// <![CDATA[
    /// RcsLocatorBuilder.AddTransient<IServiceA, ServiceA>();
    /// RcsLocatorBuilder.AddTransient<ServiceB>();
    /// RcsLocatorBuilder.AddScoped<IServiceC, ServiceC>();
    /// RcsLocatorBuilder.AddScoped<ServiceD>();
    /// RcsLocatorBuilder.AddSignletone<ServiceE>();
    /// RcsLocatorBuilder.AddSignletone<IServiceF,ServiceF>();
    /// ]]>
    /// </code>
    /// </remarks>
    private static bool CatchServiceRegistration(SyntaxNode node)
    {
        if (ContainsErrors(node))
        {
            return false;
        }

        if (node is not InvocationExpressionSyntax invocation)
        {
            return false;
        }

        if (invocation.Expression is not MemberAccessExpressionSyntax memberAccess)
        {
            return false;
        }

        if (memberAccess.Expression is not IdentifierNameSyntax identifierName)
        {
            return false;
        }

        if (identifierName.Identifier.Text is not RcsLocatorBuilderClassName or RcsLocatorBuilderFullName)
        {
            return false;
        }

        if (memberAccess.Name is not GenericNameSyntax genericName)
        {
            return false;
        }

        if (genericName.TypeArgumentList.Arguments.Count is 0 or > 2)
        {
            return false;
        }

        if (genericName.Identifier.Text is not AddTransientMethodName and not AddScopedMethodName and not AddSingletonMethodName)
        {
            return false;
        }

        return true;
    }

    private static ServiceDescriptor? GenerateServiceDescriptor(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        Diagnostic[] diagnostics = [];

        var invocation = (InvocationExpressionSyntax)context.Node;

        var memberAccess = (MemberAccessExpressionSyntax)invocation.Expression;
        var genericName = (GenericNameSyntax)memberAccess.Name;

        var serviceTypeSyntax = genericName.TypeArgumentList.Arguments[0];
        var implementationTypeSyntax = genericName.TypeArgumentList.Arguments.Count == 2
            ? genericName.TypeArgumentList.Arguments[1]
            : serviceTypeSyntax;

        var serviceType = (INamedTypeSymbol)context.SemanticModel.GetTypeInfo(serviceTypeSyntax, cancellationToken).Type!;
        var implementationType = (INamedTypeSymbol)(context.SemanticModel.GetTypeInfo(implementationTypeSyntax, cancellationToken).Type!);

        var constructor = implementationType.InstanceConstructors.Length == 1
            ? implementationType.InstanceConstructors[0]
            : implementationType.InstanceConstructors.FirstOrDefault(x => x.GetAttributes().Any(a => a.AttributeClass?.Name is InjectConstructorAttributeShortName or InjectConstructorAttributeFullName));

        if (constructor is null)
        {
            diagnostics = [Diagnostic.Create(Diagnostics.NotFoundConstructor, implementationType.Locations[0])];
        }

        return new ServiceDescriptor(
            serviceType,
            implementationType,
            constructor!,
            diagnostics,
            (IdentifierNameSyntax)genericName.TypeArgumentList.Arguments[0],
            (IdentifierNameSyntax)genericName.TypeArgumentList.Arguments.ElementAtOrDefault(1),
            genericName);
    }

    private static bool ContainsErrors(SyntaxNode node)
        => node
            .GetDiagnostics()
            .Any(d => d.Severity == DiagnosticSeverity.Error);


    private static ImmutableArray<ServiceDescriptor> ReportDiagnosticsAndSort(SourceProductionContext context, ImmutableArray<ServiceDescriptor?> serviceDescriptors)
    {
        ImmutableArray<ServiceDescriptor> filterDescriptors;

        using (var filterDescriptorsBuilder = ImmutableArrayBuilder<ServiceDescriptor>.Rent())
        {
            foreach (var serviceDescriptor in serviceDescriptors)
            {
                if (serviceDescriptor is not null)
                {
                    if (serviceDescriptor.Diagnostics.Length == 0)
                    {
                        filterDescriptorsBuilder.Add(serviceDescriptor);
                    }
                    else
                    {
                        foreach (var diagnostic in serviceDescriptor.Diagnostics)
                        {
                            context.ReportDiagnostic(diagnostic);
                        }
                    }
                }
            }

            filterDescriptors = filterDescriptorsBuilder.ToImmutable();
        }

        using var sortedDescriptorsBuilder = ImmutableArrayBuilder<ServiceDescriptor>.Rent();

        static bool FilterTransient(ServiceDescriptor descriptor) => descriptor.IsTransient;
        static bool FilterScoped(ServiceDescriptor descriptor) => descriptor.IsScoped;
        static bool FilterSingleton(ServiceDescriptor descriptor) => descriptor.IsSingleton;
        
        unsafe
        {
            SortByDependencyCount(filterDescriptors, sortedDescriptorsBuilder, &FilterTransient);
            SortByDependencyCount(filterDescriptors, sortedDescriptorsBuilder, &FilterScoped);
            SortByDependencyCount(filterDescriptors, sortedDescriptorsBuilder, &FilterSingleton);
        }

        return sortedDescriptorsBuilder.ToImmutable();

    }

    private static unsafe void SortByDependencyCount(
        ImmutableArray<ServiceDescriptor> serviceDescriptors,
        ImmutableArrayBuilder<ServiceDescriptor> sortedDescriptors,
        delegate*managed<ServiceDescriptor, bool> filter)
    {
        var count = serviceDescriptors.Length;
        var pool = ArrayPool<ServiceDescriptor>.Shared;
        var tempArray = pool.Rent(count);

        try
        {
            var filteredCount = 0;
            for (var i = 0; i < count; i++)
            {
                var descriptor = serviceDescriptors[i];
                if (filter(descriptor))
                {
                    tempArray[filteredCount++] = descriptor;
                }
            }

            // Sort by the number of dependencies (constructor parameters)
            for (var i = 0; i < filteredCount - 1; i++)
            {
                for (var j = i + 1; j < filteredCount; j++)
                {
                    if (tempArray[i]!.Constructor.Parameters.Length > tempArray[j]!.Constructor.Parameters.Length)
                    {
                        (tempArray[j], tempArray[i]) = (tempArray[i], tempArray[j]);
                    }
                }
            }

            // Add to the final list
            for (var i = 0; i < filteredCount; i++)
            {
                sortedDescriptors.Add(tempArray[i]);
            }
        }
        finally
        {
            // Return the array to the pool
            pool.Return(tempArray, clearArray: true);
        }
    }

    private static MethodDeclarationSyntax AddServiceRegister(ServiceDescriptor serviceDescriptor)
    {
        serviceDescriptor.MethodSuffix = Guid.NewGuid().ToString("N");
        // Generate method name with suffix
        var methodName = $"GetService_{serviceDescriptor.MethodSuffix}";

        // Generate parameters for the method (constructor parameters)
        var parameters = serviceDescriptor.Constructor.Parameters.Select(param =>
            SyntaxFactory.Argument(SyntaxFactory.InvocationExpression(
                SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                    SyntaxFactory.IdentifierName("RcsLocator.Current"),
                    SyntaxFactory.IdentifierName("GetRequiredService")))
                .AddArgumentListArguments(SyntaxFactory.Argument(SyntaxFactory.TypeOfExpression(
                    SyntaxFactory.ParseTypeName(param.Type.ToDisplayString()))))
            )
        ).ToArray();

        // Create the method body
        var methodBody = SyntaxFactory.Block(
            SyntaxFactory.SingletonList<StatementSyntax>(
                SyntaxFactory.ReturnStatement(
                    SyntaxFactory.ObjectCreationExpression(
                        SyntaxFactory.ParseTypeName(serviceDescriptor.ImplementationType.ToDisplayString()))
                    .AddArgumentListArguments(parameters)
                )
            )
        );

        // Generate method declaration
        var methodDeclaration = SyntaxFactory.MethodDeclaration(
                SyntaxFactory.ParseTypeName(serviceDescriptor.ServiceType.Name),
                methodName)
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                          SyntaxFactory.Token(SyntaxKind.StaticKeyword))
            .WithBody(methodBody);

        return methodDeclaration;
    }
}
